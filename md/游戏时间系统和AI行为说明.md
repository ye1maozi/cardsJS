# 游戏时间系统和AI行为说明

## 游戏机制概述

这个卡牌对战游戏采用了**基于时间的实时系统**，而不是传统的回合制。这意味着：

1. **游戏是实时进行的**，不需要玩家手动结束回合
2. **抽牌和能量恢复都是基于时间自动进行的**
3. **电脑AI会在特定时间点自动行动**

## 时间系统详解

### 1. 游戏时间计算

```javascript
// 游戏时间从游戏开始时刻计算
this.gameTime = (currentTime - this.gameStartTime) / 1000; // 转换为秒
```

### 2. 抽牌时间系统

#### 玩家抽牌
- **基础间隔**: 3秒（可在配置中调整）
- **敏捷影响**: 玩家敏捷属性会影响抽牌速度
- **计算公式**: `实际间隔 = 基础间隔 / (1 + 敏捷值 * 0.1)`

#### 电脑抽牌
- **基础间隔**: 3秒
- **敏捷影响**: 电脑敏捷属性会影响抽牌速度
- **AI触发**: 每次抽牌后会自动触发AI决策

### 3. 能量恢复系统

- **恢复间隔**: 1秒
- **恢复量**: 1点能量
- **上限**: 最大能量值（通常为10）

## AI行为机制

### 1. AI触发时机

电脑AI会在以下时机自动行动：

1. **抽牌后**: 每次电脑抽牌完成后，延迟500ms执行AI决策
2. **手动测试**: 可以通过测试页面手动触发AI决策

### 2. AI决策流程

```javascript
computerTurn() {
    // 1. 创建或获取BotPlayer实例
    if (!this.botPlayer) {
        this.botPlayer = new BotPlayer(this);
    }
    
    // 2. 执行AI决策
    const result = this.botPlayer.executeTurn();
    
    // 3. 返回决策结果
    return result;
}
```

### 3. AI决策逻辑

#### 策略分析
AI会根据当前局势选择策略：
- **攻击策略**: 当玩家血量低或威胁等级低时
- **防御策略**: 当电脑血量低或威胁等级高时
- **连击策略**: 当有连击机会时
- **平衡策略**: 默认策略

#### 卡牌选择
AI会评估每张可用卡牌的评分：
- **伤害卡牌**: 根据玩家血量、威胁等级评分
- **治疗卡牌**: 根据电脑血量、威胁等级评分
- **护甲卡牌**: 根据电脑血量、威胁等级评分
- **控制卡牌**: 根据玩家手牌数量、血量评分
- **状态卡牌**: 根据玩家血量评分

#### 英雄技能使用
AI会根据职业和局势判断是否使用英雄技能：
- **战士**: 血量低或玩家血量低时使用
- **法师**: 有高伤害法术时使用
- **盗贼**: 血量低时使用
- **牧师**: 血量低时使用

## 游戏启动流程

### 1. 页面加载
```javascript
document.addEventListener('DOMContentLoaded', async function() {
    // 1. 加载配置
    await ConfigManager.loadAllConfigs();
    
    // 2. 创建游戏实例
    game = new Game();
    
    // 3. 初始化游戏
    await game.initialize();
    
    // 4. 显示开始界面
    showStartScreen();
});
```

### 2. 游戏开始
```javascript
function startGame() {
    // 1. 隐藏开始界面
    hideStartScreen();
    
    // 2. 显示游戏界面
    game.gameUI.showGameInterface();
    
    // 3. 开始游戏
    game.start();
}
```

### 3. 游戏循环
```javascript
startGameLoop() {
    const gameLoop = () => {
        // 1. 更新游戏状态
        this.gameState.update();
        
        // 2. 更新UI
        this.gameUI.update();
        
        // 3. 继续循环
        requestAnimationFrame(gameLoop);
    };
    
    requestAnimationFrame(gameLoop);
}
```

## 常见问题解答

### Q: 为什么电脑没有行动？
**A**: 可能的原因：
1. **游戏未开始**: 需要点击"开始游戏"按钮
2. **时间未到**: 电脑只在抽牌后行动，需要等待抽牌间隔
3. **没有可用卡牌**: 电脑手牌为空或能量不足

### Q: 如何让电脑立即行动？
**A**: 可以通过以下方式：
1. **等待自然时间**: 让游戏运行到抽牌时间
2. **使用测试页面**: 打开 `test/test-ai-action.html` 手动触发
3. **修改配置**: 调整抽牌间隔时间

### Q: 游戏是回合制还是实时制？
**A**: 游戏采用**实时制**：
- 不需要手动结束回合
- 抽牌和能量恢复自动进行
- 电脑AI在特定时间点自动行动
- 玩家可以随时使用卡牌（如果有足够能量）

### Q: 如何调整游戏速度？
**A**: 可以通过修改配置：
```javascript
// 在ConfigData.js中调整
"DrawInterval": 2,  // 抽牌间隔（秒）
"EnergyPerTurn": 2, // 每回合能量恢复量
```

## 调试和测试

### 1. 使用测试页面
打开 `test/test-ai-action.html` 可以：
- 查看游戏状态
- 手动触发AI决策
- 模拟时间流逝
- 查看详细日志

### 2. 开发者工具
在浏览器控制台可以使用：
```javascript
// 查看游戏状态
gameCommands.status();

// 查看版本信息
gameCommands.version();

// 重新开始游戏
gameCommands.restart();
```

### 3. 日志输出
游戏会在控制台输出详细日志：
- AI决策过程
- 时间系统更新
- 卡牌使用情况
- 错误信息

## 性能优化

### 1. 游戏循环优化
- 使用 `requestAnimationFrame` 确保流畅运行
- 避免在游戏循环中进行复杂计算
- 合理控制日志输出频率

### 2. AI性能优化
- AI决策使用缓存机制
- 限制历史记录数量
- 使用高效的评分算法

### 3. 内存管理
- 及时清理不需要的对象
- 避免内存泄漏
- 合理使用事件监听器

## 总结

游戏的时间系统和AI行为机制设计为：
1. **实时性**: 提供流畅的游戏体验
2. **自动化**: 减少玩家操作负担
3. **智能性**: AI能够根据局势做出合理决策
4. **可调试**: 提供完整的测试和调试工具

这种设计让游戏既保持了卡牌游戏的策略性，又增加了实时对战的紧张感。 